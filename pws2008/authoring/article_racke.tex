% CLONE TICKETS !!
% Konformität
% Anwendung

%% -*- mode: latex; -*-

\section{Automatisierung und Integration von Request Tracker Systemen mittels REST-Schnittstelle}

\subsection*{Autor}
Stefan Hornburg (Racke) \verb/<racke@linuxia.de>/

\subsection*{Kurzbiographie}
Stefan Hornburg arbeitet seit 1998 als Open Source Consultant mit den
Schwerpunkten Linux, Perl und Interchange. Als Captain der ICDEVGROUP leitet
er die Entwicklergruppe von Interchange und ist als Debian Maintainer für
verschiedene Serverpakete verantwortlich (u.a. Courier, Pure-FTPd und
Sympa).

\subsection*{Einführung}
Request Tracker (RT) ist ein in Perl programmiertes
Trouble-Ticket-System. Neben großen Organisationen wie die NASA und dem MIT
wird RT auch für das Bugtracking von CPAN und Perl selbst verwendet. 

Tickets können interaktiv im Browser oder durch Emails bearbeitet werden. Um
typische Aufgaben automatisieren zu können, bietet RT sowohl eine Perl API
und als auch eine REST-Schnittstelle an. Während für die API der größere
Funktionsumfang spricht, erlaubt die REST-Schnittstelle Kommunikation mit
Installationen auf anderen Rechnern und benötigt keine Zugriffsrechte auf
die Konfigurationsdatei, die sensible Informationen wie den
Datenbankbenutzer und das Datenbankpasswort enthält. 

Für meine Projekte (Bugtracking-System für Interchange und Zusammenfassung
der Informationen von mehreren RT-Systeme meiner Kunden) habe ich den Weg
über die REST-Schnittstelle gewählt. 

Die REST-Schnittstelle erlaubt den Zugriff auf die Tickets, deren
Transaktionen und alle zugehörigen Dateien (Attachments). Neben 
dem Abruf aller Informationen zu einem Ticket und der Suche können
verschiedene Operationen durchgeführt werden, um Tickets zu
bearbeiten. Darunter fällt das Hinzufügen von Kommentaren, Zusammenfassen,
Referenzierung und die Übernahme von Tickets. 

Der Vortrag erläutert die Grundlagen von REST, die verfügbaren Funktionen
der Schnittstelle von RT und die Programmierung mit Hilfe von LWP (libwww-perl).

\subsection{Definition von \WSIndex{REST}}
Der Begriff Representational State Transfer (REST) wurde durch die
Dissertation von Roy Fielding \cite{racke:fielding} geprägt. REST bezeichnet
einen Softwarearchitekturstil für verteilte
Hypermedia-Informationssysteme wie das World Wide Web.


Die vier Grundprinzipien von REST sind:

\begin{itemize}
% wiki 1.
\item Funktionalität und Status der Anwendung ist in Ressourcen aufgeteilt
% wiki 2.
\item Adressierbarkeit, universelle Syntax zur Identifikation von
  Ressourcen, jede Ressource ist eindeutig durch ihre URI addressierbar
\item Zustandslosigkeit
\item Menge von wohldefinierten Operationen, die auf alle Ressourcen
  angewandt werden können (für HTTP u.a. GET, POST, PUT und DELETE)
\end{itemize}

Systeme, die Fieldings Prinzipien entsprechend, werden oft als REST-konform
(Englisch ``RESTful'') bezeichnet.

%\subsection{Request Tracker}
%
%Jedes Objekt in RT hat einen Type (\verb/ticket/, \verb/queue/) und eine
%numerische ID.

\subsection{REST-Schnittstelle des Request Trackers}

Die REST-Schnittstelle von RT erlaubt die Abfrage und Manipulation von
verschiedenen Objekten: Queues, Benutzer, Benutzergruppen und Tickets. 

Jede Anfrage an die Schnittstelle beinhaltet eine Aktion:

\begin{description}
\item [list] Auflistung/Suche von Objekten
\item [show] Anzeige von Objekteigenschaften
\item [create] Anlegen von Objekten
\item [edit] Bearbeitung von Objekten
\end{description}

Weitere Parameter dienen zur genaueren Spezifikation der Aktion bzw.
der Antwort:

\begin{description}
\item query
\item orderby
\item format
\end{description}

\subsubsection{Adressierung}
Die REST-Schnittstelle wird über die URI der RT-Instanz mit der
Pfadangabe /REST/1.0/ angesprochen, also z.B.:

\begin{verbatim}
http://support.linuxia.de/rt/REST/1.0/
\end{verbatim}

An diese URI wird der Name der jeweiligen Aktion angehängt:

\begin{verbatim}
http://support.linuxia.de/rt/REST/1.0/show
\end{verbatim}

Damit ist die REST-Konformität aber schon am Ende. Es wird für alle
HTTP-Anfragen die POST-Methode verwendet und weitere Parameter werden
im Body platziert. Dies verletzt die Prinzipien der 
Adressierbarkeit und wohldefinierter Ressourcen.

\subsubsection{Nutzung von der Kommandozeile}
Mit dem Kommandozeilentool /usr/bin/rt kann man sich recht gut einen
Überblick über die Funktionsweise der REST-Schnittstelle verschaffen.

Ticket anlegen:
\begin{verbatim}
$ rt create -t ticket set subject='Ausarbeitung des Vortrags' \
  set queue='Perlworkshop' 
\end{verbatim}

Im folgenden Beispiel, 
Benutzer anzeigen:

verwendet die
REST-Schnittstelle. Zum Beispiel kann man sich die Informationen
zu einem Benutzer anzeigen lassen:

\begin{verbatim}
erebus:~# rt show user/racke
URI: http://rt.icdevgroup.org/REST/1.0/show
id: user/22
Name: racke
Password: ********
EmailAddress: racke@linuxia.de
RealName: Stefan Hornburg
NickName: Racke
Lang: en
\end{verbatim}

Gleichwertig ist der Befehl rt show user/22

Die HTTP-Abfrage und Antwort
kann mit der Umgebungsvariable \WSIndex{RTDEBUG} sichtbar gemacht werden:

\begin{verbatim}
racke@erebus:~$ RTDEBUG=3 rt show -t user racke
POST http://erebus.linuxia.de/rt/REST/1.0/show
Content-Length: 77
Content-Type: multipart/form-data; boundary=xYzZY
Cookie: RT_SID_rt.linuxia.de.80=78eaf4d45b0e99fa6c05ae82ddb950f4

--xYzZY
Content-Disposition: form-data; name="id"

user/racke
--xYzZY--
HTTP/1.1 200 OK
Connection: close
Date: Tue, 15 Jan 2008 14:00:09 GMT
Server: Apache/2.2.3 (Debian) PHP/5.2.0-8+etch9 mod_ssl/2.2.3 OpenSSL/0.9.8c mod_perl/2.0.2 Perl/v5.8.8
Content-Type: text/plain; charset=utf-8
Client-Date: Tue, 15 Jan 2008 14:00:10 GMT
Client-Peer: 127.0.1.1:80
Client-Response-Num: 1
Client-Transfer-Encoding: chunked

RT/3.6.4 200 Ok

id: user/32
Name: racke
Password: ********
EmailAddress: racke@linuxia.de
\end{verbatim}

Die Kommunikation mit Request Tracker ist nicht genauer spezifiziert.
Deshalb habe ich den Aufbau der Anfragen und die Auswertung der Antworten
nach dem Motto RTSL (Read the Source, Luke) aus dem Quellcode des
Kommandozeilentools abgeleitet.

\subsection{Kommunikation über die REST-Schnittstelle}
\subsubsection{Aufbau der HTTP-Anfrage}
An die URI der REST-Schnittstelle wird die gewünschte Funktion angehängt,
alle weiteren Parameter werden im Body der HTTP-Anfrage übergeben.

\begin{verbatim}
http://support.linuxia.de/rt/REST/1.0/show
\end{verbatim}

\subsection{Implementierung}
Die Implementierung der HTTP-Kommunikation wird mit dem bekannten Perlmodul
\WSIndex{LWP::UserAgent} durchgeführt.

\begin{verbatim}
my ($ua, $req, $res);

$ua = new LWP::UserAgent(agent => "Vend::RT/1.0", env_proxy => 1);
$req = POST($uri, $data, Content_Type => 'form-data');
$res = $ua->request($req);
\end{verbatim}

\subsection{Authentifizierung}
Die REST-Schnittstelle unterstützt keine HTTP-Authentifizierung.

\subsection{Fehlerbehandlung}
Fehlerhafte Eingabeparameter werden von RT im \emph{Body} der HTTP-Antwort
quittiert:
\begin{verbatim}
RT/3.6.4 400 Bad Request
 
No objects specified.
\end{verbatim}

% liste der möglichen Fehler

\begin{thebibliography}{99}
\bibitem{racke:fielding} Fielding, Roy Thomas. 
\emph{Architectural Styles and Design of Network-Based Software Architectures}.
University of California, Irvine, 2000.
\bibitem{racke:restped} Representational State Transfer
%\texttt{http://de.wikipedia.org/wiki/Representational_State_Transfer}
\bibitem{racke:restfulws} Leonard Richardson und Sam Ruby.
\emph{RESTful Web Services}.
O'Reilly, Sebastopol, California, 2007.
\end{thebibliography}


