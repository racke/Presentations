% CLONE TICKETS !!


%% -*- mode: latex; -*-

\section{Automatisierung und Integration von Request Tracker Systemen mittels REST-Schnittstelle}

\subsection*{Autor}
Stefan Hornburg (Racke) \verb/<racke@linuxia.de>/

\subsection*{Kurzbiographie}
Stefan Hornburg arbeitet seit 1998 als Open Source Consultant mit den
Schwerpunkten Linux, Perl und Interchange. Als Captain der ICDEVGROUP leitet
er die Entwicklergruppe von Interchange und ist als Debian Maintainer für
verschiedene Serverpakete verantwortlich (u.a. Courier, Pure-FTPd und
Sympa). Er betreut Mailserver für seine Kunden seit 1999.

\subsection*{Einführung}
Request Tracker (RT) ist ein in Perl programmiertes
Trouble-Ticket-System. Neben großen Organisationen wie die NASA und dem MIT
wird RT auch für das Bugtracking von CPAN und Perl selbst verwendet. 

Tickets können interaktiv im Browser oder durch Emails bearbeitet werden. Um
typische Aufgaben automatisieren zu können, bietet RT sowohl eine Perl API
und als auch eine REST-Schnittstelle an. Während für die API der größere
Funktionsumfang spricht, erlaubt die REST-Schnittstelle Kommunikation mit
Installationen auf anderen Rechnern und benötigt keine Zugriffsrechte auf
die Konfigurationsdatei, die sensible Informationen wie den
Datenbankbenutzer und das Datenbankpasswort enthält. 

Für meine Projekte (Bugtracking-System für Interchange und Zusammenfassung
der Informationen von mehreren RT-Systeme meiner Kunden) habe ich den Weg
über die REST-Schnittstelle gewählt. 

Die REST-Schnittstelle erlaubt den Zugriff auf die Tickets, deren
Transaktionen und alle zugehörigen Dateien (Attachments). Neben 
dem Abruf aller Informationen zu einem Ticket und der Suche können
verschiedene Operationen durchgeführt werden, um Tickets zu
bearbeiten. Darunter fällt das Hinzufügen von Kommentaren, Zusammenfassen,
Referenzierung und die Übernahme von Tickets. 

Der Vortrag erläutert die Grundlagen von REST, die verfügbaren Funktionen
der Schnittstelle von RT und die Programmierung mit Hilfe von LWP (libwww-perl).

\subsection{\WSIndex{REST}}
% cut & waste from Wikipedia
Der Begriff Representational State Transfer (REST) bezeichnet einen Softwarearchitekturstil für verteilte Hypermedia-Informationssysteme. Während die Architektur des World Wide Webs durch den URI Standard und das HTTP Protokoll beschrieben werden kann, diente der REST Architekturstil seit 1994 als Richtlinie für die Weiterentwicklung der bestehenden Standards.

REST stammt aus der Dissertation von Roy Fielding, in welcher der Erfolg des
World Wide Webs auf bestimmte Eigenschaften der verwendeten Mechanismen und
Protokolle (z.B. HTTP) zurückgeführt wird. Roy Fielding ist einer der
Hauptautoren der Spezifikation des Hypertext-Transfer-Protokolls (HTTP).
% cut & waste from Wikipedia

\subsection{Request Tracker}

Jedes Objekt in RT hat einen Type (\verb/ticket/, \verb/queue/) und eine
numerische ID.

\subsection{REST-Schnittstelle des Request Trackers}

\subsubsection{Funktionen}
Folgende Objekte können angesprochen werden:

\begin{itemize}
\item Queues (queue)
\item Tickets (ticket)
\item Benutzer (user)
\end{itemize}

Folgende Aktionen können ausgeführt werden:

\begin{itemize}
\item show
\item create
\item edit
\end{itemize}

\subsubsection{CLI}
Das Kommandozeilentool /usr/bin/rt verwendet die
REST-Schnittstelle. Zum Beispiel kann man sich die Informationen
zu einem Benutzer anzeigen lassen:

\begin{verbatim}
erebus:~# rt show user/racke
URI: http://rt.icdevgroup.org/REST/1.0/show
id: user/22
Name: racke
Password: ********
EmailAddress: racke@linuxia.de
RealName: Stefan Hornburg
NickName: Racke
Lang: en
\end{verbatim}

Gleichwertig ist der Befehl rt show user/22

Die HTTP-Abfrage und Antwort
kann mit der Umgebungsvariable \WSIndex{RTDEBUG} sichtbar gemacht werden:

\begin{verbatim}
racke@erebus:~$ RTDEBUG=3 rt show -t user racke
POST http://erebus.linuxia.de/rt/REST/1.0/show
Content-Length: 77
Content-Type: multipart/form-data; boundary=xYzZY
Cookie: RT_SID_rt.linuxia.de.80=78eaf4d45b0e99fa6c05ae82ddb950f4

--xYzZY
Content-Disposition: form-data; name="id"

user/racke
--xYzZY--
HTTP/1.1 200 OK
Connection: close
Date: Tue, 15 Jan 2008 14:00:09 GMT
Server: Apache/2.2.3 (Debian) PHP/5.2.0-8+etch9 mod_ssl/2.2.3 OpenSSL/0.9.8c mod_perl/2.0.2 Perl/v5.8.8
Content-Type: text/plain; charset=utf-8
Client-Date: Tue, 15 Jan 2008 14:00:10 GMT
Client-Peer: 127.0.1.1:80
Client-Response-Num: 1
Client-Transfer-Encoding: chunked

RT/3.6.4 200 Ok

id: user/32
Name: racke
Password: ********
EmailAddress: racke@linuxia.de
\end{verbatim}

 Nach dem Motto RTSL (Read the Source, Luke) habe ich die
Kommunikation und Auswertung dort abgeschaut.



\subsection{Kommunikation über die REST-Schnittstelle}
\subsubsection{Aufbau der HTTP-Anfrage}
Die URL setzt sich zusammen aus der URL der Request Tracker-Instanz, der
Zeichenkette REST/1.0 und der gewünschten Aktion.

\begin{verbatim}
http://support.linuxia.de/rt/REST/1.0/show
\end{verbatim}

Alle weiteren Parameter werden im Inhalt vom HTTP POST übermittelt. Das
widerspricht dem Geiste von REST.

\subsection{Implementierung}
Die Implementierung der HTTP-Kommunikation wird mit dem bekannten Perlmodul
\WSIndex{LWP::UserAgent} durchgeführt.

\begin{verbatim}
my $ua = new LWP::UserAgent(agent => "Vend::RT/1.0", env_proxy => 1);
\end{verbatim}

\subsection{Authentifizierung}

\subsection{Fehlerbehandlung}
Fehlerhafte Eingabeparameter werden von RT im \emph{Body} der HTTP-Antwort
quittiert:
\begin{verbatim}
RT/3.6.4 400 Bad Request
 
No objects specified.
\end{verbatim}

% liste der möglichen Fehler

\begin{thebibliography}{99}
\bibitem{racke:restped} Representational State Transfer
%\texttt{http://de.wikipedia.org/wiki/Representational_State_Transfer}
\bibitem{racke:restfulws} RESTful Web Services
\end{thebibliography}


