\usepackage[T1]{fontenc}
\usepackage{mathptmx}
\usepackage[scaled=.90]{helvet}
\usepackage{courier}

\usepackage{beamerthemesplit}
\usepackage{verbatim}
\usepackage{hyperref}
\usepackage{listings}
\lstset{language=Perl,basicstyle=\footnotesize,tabsize=3,showstringspaces=false}

\title{Tanz!}
\author[racke]{Stefan Hornburg (Racke)\\ \texttt{racke@linuxia.de}}
\date[GPW2011]{13. Deutscher Perl-Workshop, Frankfurt, 21. Oktober 2011}


\begin{document}
\maketitle{}

\begin{frame}
  \titlepage
\end{frame}

\tableofcontents

\section{Projekte}
\begin{frame}{Projekte}
\begin{itemize}
\item Dropbox-Klon
\item LDAP Benutzerverwaltung
\item Buchladen
\end{itemize}
\end{frame}

\subsection{Dropbox}
Für die Firma Caithness in New York habe ich einen Dropbox-Klon
entwickelt.

\begin{frame}{Dropbox}
\begin{itemize}
\item Autoindex
\item Upload/Download
\item Benutzerverwaltung
\end{itemize}
\end{frame}

\subsection{LDAP Benutzerverwaltung}
\begin{frame}{LDAP Benutzerverwaltung}
\begin{itemize}
\item LDAP
\end{itemize}
\end{frame}

\subsection{Buchladen}
\begin{frame}{Buchladen}
\begin{itemize}
\item LibraryThing
\item ISBNDB
\end{itemize}
\end{frame}

\section{Routes, Filter und Hooks}
\subsection{Routes}

\begin{frame}{Routes}
\begin{itemize}
\item Splat
\item Megasplat
\item Regex
\item Regex mit captures
\end{itemize}
\end{frame}

\subsubsection{Splat}
\begin{frame}[fragile]{Splat}
\begin{lstlisting}
get '/images/covers/*.jpg' => sub {
    my ($isbn) = splat;

    if (-f "public/images/covers/$isbn.jpg") {
        return send_file "images/covers/$isbn.jpg";
    }

    status 'not_found';
    forward 404;
}
\end{lstlisting}
\end{frame}

\subsubsection{Megasplat}

\begin{frame}[fragile]{Megasplat}
\begin{lstlisting}
get '/lostpwd/**' => sub {
    my ($email, $hash) = splat;

    form->fill(email => $email,
               hash => $hash);
    
    template('lostpwd_confirm', form => $form);
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Captures}
\begin{lstlisting}
any qr{^/~(?<user>[^/]+)/(?<file>.*?)/?$} => sub {
    my ($capts, $user, $file);

    $capts = captures;
    $file = $capts->{file};
    $user = $capts->{user};

    ...
};
\end{lstlisting}
\end{frame}

\subsection{Filters}
\begin{frame}[fragile]{Filters}
\begin{lstlisting}
before sub {
};

after sub {
};
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{before}
\begin{lstlisting}
before sub {
    unless (session('user')
        || request->path eq '/login'
        || request->path =~ m%^/lostpwd%
        ) {
        redirect '/login';
    }
};
\end{lstlisting}
\end{frame}

\subsection{Hooks}
\begin{frame}{Hooks}
\end{frame}

Die folgenden Hooks existieren in Dancer:

\begin{itemize}
\item before\_deserializer
\item before\_file\_render
\item before\_error\_init
\item before\_error\_render
\item before\_template\_render
\item before\_layout\_render
\item before\_serializer
\item after\_deserializer
\item after\_file\_render
\item after\_template\_render
\item after\_layout\_render
\item after\_error\_render
\end{itemize}

Der after\_file\_render-Hook wird ausgelöst, nachdem eine statische
Datei (Bild oder CSS-Datei) gesendet wurde.

% \section{Exceptions}
% Exceptions in Dancer sind nicht objektorientiert, um sie
% leichtgewichtig und schnell zu halten.
% \begin{frame}{Exceptions}
% \end{frame}

\section{Plugins}
\begin{frame}{Plugins}
\begin{itemize}
\item Konfiguration
\item Funktionalität
\item Schlüsselwort
\item Route 
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Dancer::Plugin::LibraryThing Konfiguration}
\begin{lstlisting}
plugins:
    LibraryThing:
        api_key: d231aa37c9b4f5d304a60a3d0ad1dad4
        directory: public/images/covers
        size: large
\end{lstlisting}
\end{frame} 

\begin{frame}[fragile]{Dancer::Plugin::LibraryThing Code}
\begin{lstlisting}
use Dancer::Plugin::LibraryThing;

get '/images/covers/*.jpg' => sub {
    my ($isbn, @ret);

    $isbn = splat;

    unless (-f "public/images/covers/$isbn.jpg") {
        @ret = librarything_cover($isbn);

        if (@ret < 3) {
            status 'not_found';
            forward 404;
        }
    }

    return send_file "images/covers/$isbn.jpg";
}
\end{lstlisting}
\end{frame}

% thin wrapper around CPAN module
% add keywords (avoid overlaps)
% add configuration

\subsection{Writing Plugins}
\begin{frame}{Writing Plugins}
\begin{itemize}
\item register
\item register\_plugin
\item plugin\_setting
\end{itemize}
\end{frame}

\subsection{Plugins und Hooks}
\begin{frame}[fragile]{Plugins und Hooks}
\begin{lstlisting}
Dancer::Factory::Hook
        ->instance
        ->install_hooks('before_cart_add');
\end{lstlisting}
\end{frame}

\section{Deployment und Entwicklung}
\subsection{Sessions}
Die Session-Engine wird mit \verb|session| konfiguriert,
ansonsten werden keine Sessions verwendet. Cookies sind
Voraussetzung für Sessions mit Dancer.

YAML-Sessions und JSON-Sessions sind nur für die Entwicklung gedacht

Alternativen sind u.a.:
\begin{itemize} 
\item Storable
\item Cookie
\item Memcached
\item MongoDB
\end{itemize}

Eine gute Idee ist es die Session Engine für den Produktionsbetrieb
in \verb|config.yml| zu konfigurieren und für die Entwicklung in
\verb|environments/development.yml| zu überschreiben.

Im Produktionsbetrieb ist es empfehlenswert die Ablauffrist für
Sessions zu setzen, sonst ist eine Session für immer gültig.

\begin{frame}[fragile]{Sessions}
\begin{itemize} 
\item Engine \\
\verb|session: Storable|
\item Verzeichnis \\
\verb|session_dir: /var/run/dancer-sessions|
\item Ablauffrist \\
\verb|session_expires: 8 hours|
\end{itemize} 
\end{frame}

\subsection{Perlbal}
\begin{frame}[fragile]{Perlbal}
\begin{lstlisting}
LOAD vpaths
XS enable headers
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Perlbal: Starman}
\begin{lstlisting}
CREATE POOL prod_starman_dosqua
 POOL prod_starman_dosqua ADD 127.0.0.1:5000

CREATE POOL prod_starman_vsc
 POOL prod_starman_vsc ADD 127.0.0.1:5001
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Perlbal: Reverse Proxy}
\begin{lstlisting}
CREATE SERVICE vsc_prod
 SET role                 = reverse_proxy
 SET pool                 = prod_starman_vsc
 SET buffer_uploads       = on
ENABLE vsc_prod
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Perlbal: Selector}
\begin{lstlisting}
CREATE SERVICE vsc_selector
 SET listen              = 86.59.13.238:80
 SET role                = selector
 SET plugins             = vpaths
 VPATH .*                = vsc_prod
ENABLE vsc_selector
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Perlbal: SSL Selector}
\begin{lstlisting}
CREATE SERVICE vsc_ssl_selector
 SET listen              = 86.59.13.238:443
 SET role                = selector
 SET plugins             = vpaths
 SET enable_ssl          = on
 SET ssl_key_file        = /etc/ssl/private/vsc.state.gov.key
 SET ssl_cert_file       = /etc/ssl/certs/vsc.state.gov.pem
 VPATH .*                = vsc_prod
ENABLE vsc_ssl_selector
HEADER vsc_ssl_selector INSERT X-Forwarded-Proto: HTTPS
\end{lstlisting}
\end{frame}

\subsection{Starman}
\begin{frame}[fragile]{Starman}
\begin{lstlisting}
plackup -E production 
        -s Starman \ 
        --workers=5 \
        --pid /home/racke/Dropbox/run/Dropbox.pid \
        -p 5000 \ 
        -a bin/app.pl \
        -D
\end{lstlisting}
\end{frame}


\subsection{Skripts}
\begin{frame}[fragile]{Skripts}
Dancer-Skripts sollten innerhalb der Dancer-Applikation
liegen, gut geeignet ist das bin/-Verzeichnis. Ein symbolischer
Link is ausreichend. Ansonsten wird die Konfiguration nicht gefunden.

\begin{lstlisting}
use Dancer ':script';

set logger => 'console';
set logger_format => '%m';
\end{lstlisting}
\end{frame}

\subsection{Dancer 2}
\begin{frame}{Dancer2}

\begin{itemize} 
\item keine globalen Variablen
\item 100\% OO Backend (Moo)
\item Scoping for Sub-Applikationen
\item überarbeitete Architektur
\end{itemize}

\end{frame}

\end{document}
