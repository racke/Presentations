
\usepackage[T1]{fontenc}
\usepackage{mathptmx}
\usepackage[scaled=.90]{helvet}
\usepackage{courier}

\usepackage{beamerthemesplit}
\usepackage{verbatim}
\usepackage{hyperref}
\usepackage{listings}
\lstset{language=Perl,basicstyle=\footnotesize,tabsize=3,showstringspaces=false}

\title{Template::Zoom - Modern HTML and PDF Engine}
\author[racke]{Stefan Hornburg (Racke)\\ \texttt{racke@linuxia.de}}
\date[APW2010]{Perl Oasis 2011, 15th January 2011}

\begin{document}
\maketitle{}

\begin{frame}
  \titlepage
\end{frame}

\tableofcontents

\section{Template::Zoom}
Template::Zoom enables you to completely separate web design and programming
tasks for dynamic web applications. 

Templates are plain HTML files without inline code or mini language, thus
making it easy to maintain them for web designers and to preview them with
a browser.

The CSS selectors in the template are tied to your data structures or
objects by a specification, which relieves the programmer from changing
his code for mere changes of class names.

In addition to HTML output, Template::Zoom also supports generation of
PDF files on-the-fly based on the same template and specification.

\subsection{Why and Where}
\begin{frame}{Why}
  \begin{itemize}
  \item Separation of web design and programming
  \item How available template engines violate this principle
    \begin{itemize}
    \item Mini language (Template::Toolkit)
    \item Inline code
    \item CSS selectors (HTML::Zoom)
    \end{itemize}
  \item Solutions by Template::Zoom
    \begin{itemize}
      \item Static HTML file
      \item Specification file
      \item Tweaks through tree manipulations
    \end{itemize}
  \item Further Goals
    \begin{itemize}
      \item Static HTML file
      \item Specification file
      \item Tweaks through tree manipulations
    \end{itemize}
  \end{itemize}
%  \item Einarbeitungszeit für Designer reduzieren
%  \item Grenzfälle, Fehler und Bedingungen (dynamische Seiten)
%\url{http://perl.apache.org/docs/tutorials/tmpl/comparison/comparison.html}
\end{frame}

% \begin{frame}{Where}
% \end{frame}

\subsection{Cart Example}
\subsubsection{Cart as Hash}
\begin{frame}[fragile]{Cart: Hash}
\begin{lstlisting}
$cart = [
         {isbn => '978-0-2016-1622-4', 
          title => 'The Pragmatic Programmer',
          quantity => 1, price => 49.95},

         {isbn => '978-1-4302-1833-3',
          title => 'Pro Git',
          quantity => 1, price => 34.99},
		];
\end{lstlisting}
\end{frame}
\subsubsection{HTML Template}
\begin{frame}[fragile]{Cart: HTML Template}
\begin{lstlisting}
<table class="cart">
<tr class="cartheader">
<th>Name</th><th>Quantity</th><th>Price</th>
</tr>
<tr class="cartitem">
<td class="name">Perl 6</td>
<td><input class="quantity" name="quantity" size="3" value="10"></td>
<td class="price">$$$</td>
</tr>
<tr class="cartheader">
<th colspan="2"></th><th>Total</th></tr>
<tr>
<td colspan="2"></td><td class="cost">$$$</td></tr>
</table>
\end{lstlisting}
\end{frame}
\subsubsection{Cart with ITL}
\begin{frame}[fragile]{Cart: ITL}
\lstinputlisting{cart-example-basic/cart.itl}
\end{frame}
\subsubsection{Cart with Template::Toolkit}
\begin{frame}[fragile]{Cart: Template::Toolkit}
\lstinputlisting{cart-example-basic/cart.tt}
\end{frame}
\subsubsection{Cart with HTML::Zoom}
\begin{frame}[fragile]{Cart: HTML::Zoom}
\begin{lstlisting}
use HTML::Zoom;

$cart = ...
$zoom = HTML::Zoom->from_file('cart.html');

$zoom->select('.cartitem')->repeat_content([
  map { my $field = $_; sub {
    $_[0]->select('.name')->replace_content($field->{title});
    $_[0]->select('.quantity')->replace_content($field->{quantity});
    $_[0]->select('.price')->replace_content($field->{price});
    };
  } @$cart]);

print $zoom->to_html();
\end{lstlisting}
\end{frame}
\subsubsection{Template Problems}
\begin{frame}{Template Problems}
 \begin{itemize}
  \item Mini language in HTML template
  \item Dynamic pages (border cases, errors, ...)
 \end{itemize}
\end{frame}
\subsubsection{Cart with Template::Zoom}
\begin{frame}{Template::Zoom Concept}
 \begin{itemize}
  \item Specification
  \item Template
  \item Data or objects (iterator)
 \end{itemize}
\end{frame}
\subsubsection{Specification}
\begin{frame}[fragile]{Template::Zoom Specification (XML)}
\lstinputlisting{cart-example-basic/cart.xml}
\end{frame}
\begin{frame}[fragile]{Template::Zoom Specification (Config::Scoped)}
\lstinputlisting{cart-example-basic/cart.conf}
\end{frame}
\subsubsection{Quellcode}
\begin{frame}[fragile]{Template::Zoom Script (XML)}
\begin{lstlisting}
use Template::Zoom;

my ($cart, $zoom, %values);

$cart = ...
$values{cost} = ...

$zoom = new Template::Zoom(specification_file => 'cart.xml',
                           template_file => 'cart.html',
                           iterators => {cart => $cart},
                           values => \%values,
);

print $zoom->process();
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Template::Zoom Script (Config::Scoped)}
\begin{lstlisting}
use Template::Zoom;

my ($cart, $zoom, %values);

$cart = ...
$values{cost} = ...

$zoom = new Template::Zoom(specification_file => 'cart.conf',
                           specification_parser => 'Scoped',
                           template_file => 'cart.html',
                           iterators => {cart => $cart},
                           values => \%values,
);

print $zoom->process();
\end{lstlisting}
\end{frame}

You are probably missing the \$ sign in the HTML output, we see
to that later.

\subsection{Menu Example}
\subsubsection{Database table for menus}
\begin{frame}[fragile]{Menus: Database table}
\begin{lstlisting}
CREATE TABLE menus (
  code int NOT NULL auto_increment,
  name varchar(255) NOT NULL DEFAULT '',
  url  varchar(255) NOT NULL DEFAULT '',
  menu_name varchar(64) NOT NULL DEFAULT '',
  permission varchar(64) NOT NULL DEFAULT '',
  weight int NOT NULL DEFAULT 0,
  PRIMARY KEY(code),
  KEY(menu_name)
);
\end{lstlisting}
\end{frame}

\subsubsection{Specification}
\begin{frame}[fragile]{Menus: Specification}
\begin{lstlisting}
<specification name="menu" description="Menu">
<list name="menu" class="menu" table="menus">
<input name="name" required="1" field="menu_name"/>
<param name="label" field="name"/>
<param name="url"/>
</list>
</specification>
\end{lstlisting}
\end{frame}

\subsubsection{Template}
The HTML template for the menu is really simple, because the
styling can be done completely with CSS.

\begin{frame}[fragile]{Menus: Template}
\begin{lstlisting}
<ul class="menu">
<li><a href="" class="url"><span class="label"></span></li>
</ul>
\end{lstlisting}
\end{frame}

\subsubsection{Script}
\begin{frame}[fragile]{Menus: Script}
\begin{lstlisting}
use Template::Zoom;
use Template::Zoom::Database::Rose;

$db_object = new Template::Zoom::Database::Rose(dbname => 'temzoo',
    dbtype => 'Pg',
);

$zoom = new Template::Zoom(specification_file => 'menu.xml',
						   template_file => 'menu.html',
						   database => $db_object,
						  );

$zoom->process({name => main});
\end{lstlisting}
\end{frame}

\section{Lists}
\subsection{Iterators}
Template::Zoom uses iterators to retrieve list elements and insert them into
the document tree. This abstraction relieves us from worrying about where
the data actually comes from. We basically just need an array of hash
references and an iterator class with a next and a count method. For your
convenience you can create an iterator from Template::Zoom::Iterator
very easily.

\begin{frame}{Iterators}
\begin{itemize}
  \item next method
  \item count method
  \item hash as return value
  \item Template::Zoom::Iterator
 \end{itemize}
\end{frame}
\subsection{Alternating rows}
\begin{frame}[fragile]{Lists with alternating rows}
\begin{lstlisting}
<table class="cart">
<tr class="cartheader">
<th>Name</th><th>Quantity</th><th>Price</th>
</tr>
<tr class="cartitem odd">
<td class="name">Perl 6</td>
<td><input class="quantity" name="quantity" size="3" value="10"></td>
<td class="price">$$$</td>
</tr>
<tr class="cartitem even">
<td class="name">Pro Git</td>
<td><input class="quantity" name="quantity" size="3" value="10"></td>
<td class="price">$$$</td>
</tr>
</table>
\end{lstlisting}
\end{frame}

\section{Filter and Sort}
There are two types of filters for lists: global filters and
parameter filters. Global filters are applied to the complete
record of a list element and can be used to skip list items.
Parameter filters are applied to a single value in a list
element record.

\subsection{Parameter Filter}
\begin{frame}[fragile]{Filter: Specification}
\begin{lstlisting}
<specification name="menu" description="Menu">
<list name="menu" class="menu" table="menus">
<input name="name" required="1" field="menu_name"/>
<param name="label" field="name"/>
<param name="url" target="href" filter="link"/>
</list>
</specification>
\end{lstlisting}
\end{frame}

\subsection{Filter function}
\begin{frame}[fragile]{Filter: Function}
\begin{lstlisting}
sub link_filter {
    my $page = shift;
    my $url;

    $url = ...
    
    return $url;
}

$zoom = new Template::Zoom(specification_file => 'menu.xml',
						   template_file => 'menu.html',
						   database => $db_object,
						   filters => {link => \&link_filter},
						  );
\end{lstlisting}
\end{frame}

\subsection{Global Filter}
\begin{frame}[fragile]{Global Filter}
\begin{lstlisting}
<specification name="menu" description="Menu">
<filter name="acl" field="permission"/>
<list name="menu" class="menu" table="menus">
<input name="name" required="1" field="menu_name"/>
<param name="label" field="name"/>
<param name="url" target="href" filter="link"/>
</list>
</specification>
\end{lstlisting}
\end{frame}

\subsection{Specification with sort}
\begin{frame}[fragile]{Sort: Specification}
\begin{lstlisting}
<specification name="menu" description="Menu">
<list name="menu" class="menu" table="menus">
<sort name="default">
<field name="weight" direction="desc"/>
<field name="code" direction="asc"/>
</sort>
<input name="name" required="1" field="menu_name"/>
<param name="label" field="name"/>
<param name="url" target="href" filter="link"/>
</list>
</specification>
\end{lstlisting}
\end{frame}

\section{I18N}
I18N support is very basic right now. You write a function for
translating text inside the HTML template and instantiate an
Template::Zoom::I18N with a reference to this function. 
\begin{frame}[fragile]{I18N}
\begin{lstlisting}
sub translate {
    my $text = shift;

    ...

    return $text;
}

$i18n = new Template::Zoom::I18N (\&translate);

$zoom = new Template::Zoom(specification_file => 'menu.xml',
						   template_file => 'menu.html',
						   database => $db_object,
						   i18n => $i18n,
						  );
\end{lstlisting}
\end{frame}

\subsection{I18N: Lookup Keys}
You can override the text in the HTML template passed to the
translation function with a lookup key in the specification.
\begin{frame}[fragile]{I18N: Lookup Keys}
\begin{lstlisting}
<i18n name="returnurl" key="RETURN_URL"/>
\end{lstlisting}
\end{frame}

\section{Forms}
\begin{frame}[fragile]{Forms: Specification}
\begin{lstlisting}
<specification name='search' description=''>
<form name='search'>
<field name='searchterm'/>
<field name='searchsubmit'/>
</form>
</specification>
\end{lstlisting}
\end{frame}

\subsection{Manipulating Forms}
The Template::Zoom::Form class provides a number of methods
to manipulate the output of forms in the resulting HTML:

\begin{frame}{Forms: Manipulating}
  \begin{description}
  \item[set\_action] Changing form action
  \item[set\_method] Changing form method (GET, POST)
  \item[fill] Fill form fields
  \end{description}
\end{frame}

\section{PDF}
PDF generation starts just the same way as HTML template
processing. In fact, it might make sense to use the same template
for display in the browser and for producing the PDF document.

The conversion is running through 3 passes. First the position
and sizes of the boxes are calculated. Second the boxes are
partitioned throughout the pages in the PDF document.

\subsection{HTML to PDF}
\begin{frame}{HTML to PDF}
  \begin{itemize}
  \item HTML template processing
  \item PDF conversion (PDF::API2)
    \begin{enumerate}
    \item calculate
    \item partition
    \item render
    \end{enumerate}
  \item Inline CSS 
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{PDF: Code}
\begin{lstlisting}
$zoom = new Template::Zoom (specification_file => 'pdf.xml',
                            template_file => 'pdf.html',
                            values => \%values);
$zoom->process();

$pdf = new Template::Zoom::PDF (template => $zoom->template(),
                                file => 'invoice.pdf');
$pdf->process();
\end{lstlisting}
\end{frame}

\subsection{Import}
\begin{frame}[fragile]{PDF: Import}
\begin{lstlisting}
$import{file} = 'shippinglabel.pdf';
$import{scale} = 0.8;
$import{margin} = {left => '3mm', top => '6mm'};

$pdf = new Template::Zoom::PDF (template => $zoom->template(),
                                file => 'invoice.pdf',
                                import => \%import);
\end{lstlisting}
\end{frame}

% \subsection{Restrictions}
\section{Conclusion}
\subsection{Use Cases}
\begin{frame}{Current and Future Use Cases}
  \begin{itemize}
  \item Very Large Product Lists
  \item Shop Backend
    \begin{itemize}
    \item Product Editor
    \item Product Search \& Replace
    \end{itemize}
  \item PDF Invoices
  \item Template Engine for Interchange
 \end{itemize}
\end{frame}

\subsection{Roadmap}
\begin{frame}{Roadmap}
 \begin{itemize}
   \item Documentation
   \item Tests
   \item Conditions
   \item Empty lists, number of results
   \item Selected items
   \item Paging
   \item Trees 
 \end{itemize}
\end{frame}

\subsection{The End}
\begin{frame}{The End}
 \begin{description}
  \item[Git] http://git.linuxia.de/?p=temzoo.git;a=summary
  \item[CPAN] not yet
  \item[Website] not yet
  \item[Release] tomorrow?
  \item[Talk]
    http://www.linuxia.de/talks/opw2011/temzoo-opw2011-beamer.pdf
   \item[Questions] ???
 \end{description}
\end{frame}

\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
