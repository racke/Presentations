\begin{document}
\maketitle

\begin{frame}
  \titlepage
\end{frame}

\cleardoublepage

\tableofcontents

\cleardoublepage

\section{Introduction}

\note{As you can imagine, the truth is in between these extremes}

\note{
  A few words about myself:
}

\begin{frame}{Me}
\begin{itemize}
\item Nick name: racke
\item Self employed programmer since 1998
\item Web applications
\item Ecommerce
\item Database
\item Customers in Germany, Switzerland, USA, ...
\end{itemize}
\end{frame}

\note{
  One of my customers is the US Department of State.
  I'm responsible for a number of their web sites, for example
  the procurement solution eShop.
}

\begin{frame}{eShop}
\begin{figure}[!ht]
\centering
\includegraphics[width=1\linewidth]{img/eshop.png}
\end{figure}
\end{frame}

\begin{frame}{Interchange}
\begin{figure}[!ht]
\centering
\includegraphics[width=1\linewidth]{img/interchange.jpg}
\end{figure}
\end{frame}

\begin{frame}{Interchange}
\begin{itemize}
\item Embedded SQL
\item \sout{Modern Perl}
\end{itemize}
\end{frame}

\begin{frame}{Dancer / DBIx::Class}
\begin{itemize}
\item Dancer
\item DBIx::Class
\item Interchange6
\end{itemize}
\end{frame}

\note{We organized the second Perl Dancer conference October,}

\begin{frame}{Perl Dancer Conference}
\begin{figure}[!ht]
\centering
\includegraphics[width=1\linewidth]{img/perl-dancer-homepage-logo.png}
\end{figure}
\end{frame}

\note{where he had also a one day DBIx::Class training.

Here you see my co-trainers, ribasushi (mastermind behind
DBIx::Class) and Peter Mottram doing the last preparations
for the training:
}

\begin{frame}{DBIx::Class Training}
\begin{figure}[!ht]
\centering
\includegraphics[width=1\linewidth]{img/training-preps.jpg}
\end{figure}
\end{frame}

\note{Baltimore Outage April}

\begin{frame}[fragile]{Conference website}
\begin{itemize}
\item ACT 2014
\begin{itemize}
\item Legacy code
\item No server control
\end{itemize}
\item www.perl.dance 2015
\begin{itemize}
\item Dancer / DBIx::Class
\item Most ACT features + new features
\item \url{https://github.com/interchange/Perl-Dancer-Conference}
\end{itemize}
\end{itemize}
\end{frame}

\subsection{Best Thing Since Sliced Bread}

\begin{frame}{Best Thing Since Sliced Bread}

% https://en.wikipedia.org/wiki/Sliced_bread#/media/File:Brood.jpg

\begin{figure}[!ht]
\centering
\includegraphics[width=1\linewidth]{img/sliced-bread.jpg}
\end{figure}
\end{frame}

\begin{frame}{Best Thing Since Sliced Bread}
\begin{itemize}
\item OO instead of SQL
\item Abstracts different SQL implementations
\item Business Logic
\item Performance
\item ``ResultSet'' features
\item Ecosystem
\begin{itemize}
\item IRC / Mailing list
\item Components
\item Helpers
\end{itemize}
\end{itemize}
\end{frame}

\subsection{Can of Worms}

\begin{frame}{Can of Worms}
\begin{figure}[!ht]
\centering
\includegraphics[width=0.75\linewidth]{img/canofworms.png}
\end{figure}
\end{frame}

\begin{frame}{Can of Worms}
\begin{itemize}
\item SQL::Abstract
\item Class names (Result, ResultSet)
\item Based on C3 instead of Moo(se)
\item Documentation outline
\end{itemize}
\end{frame}

Using DBIx::Class allows you move all your business logic
into the database schema instead scattering it around a (web)
application.

\subsection{Business Logic}
\begin{frame}{Business Logic}
% move business logic into schema
% https://pixabay.com/en/gear-gears-euro-forex-dollar-384743/
\begin{figure}[!ht]
\centering
\includegraphics[width=0.75\linewidth]{img/business-logic.jpg}
\end{figure}
\end{frame}

\begin{frame}{Business Logic Benefits}
\begin{itemize}
\item Multiple Consumers
\begin{itemize}
\item Web application(s)
\item Cron jobs, scripts
\item Test environments
\end{itemize}
\item Hide Implementation
\begin{itemize}
\item SQL Dialects
\item Application View
\end{itemize}
\item Changes / DRY
\end{itemize}
\end{frame}

\subsection{Performance}

All the experience, tests and different areas in which 
DBIx::Class is applied makes it perform better than
handwritten SQL is most cases.

\begin{frame}{Performance}
\begin{itemize}
\item Experience
\item Test results
\item Use cases
\end{itemize}
\end{frame}
 
In case you feel that isn't correct, please call our hotline:

\begin{frame}
\begin{figure}[!ht]
\centering
\includegraphics[width=1\linewidth]{img/perldance-2014-modern-tech.jpg}
\end{figure}
\end{frame}

But if you want to resort to SQL at some point, DBIx::Class allows you
to that too

\begin{frame}[fragile]{Literal SQL}
\begin{lstlisting}
$schema->resultset('PlaceVisited')->search(
{
  users_id => {
    -in => \[
       'SELECT users_id FROM users WHERE users_id > ?',
       2
    ]
  }
});
\end{lstlisting}
\end{frame}

But please don't complain if that leads to headache
and wasted time better spent on proper DBIx::Class
code.

\begin{frame}{SQL Headache}
% https://pixabay.com/en/stress-man-hand-flame-burn-fire-864141/
\begin{figure}[!ht]
\centering
\includegraphics[width=1\linewidth]{img/stress.jpg}
\end{figure}
\end{frame}

\section{Set Based DBIx::Class}

\note{The most important feature of DBIx::Class is the Resultset,
which we will examine through an example soon.}

\begin{frame}[fragile]{Set Based DBIx::Class}
\begin{figure}[!ht]
\centering
\includegraphics[width=0.4\linewidth]{img/frew.png}
\caption{Arthur Axel "fREW" Schmidt}
\end{figure}
\centering
\href{http://www.perladvent.org/2012/2012-12-21.html}{http://www.perladvent.org/2012/2012-12-21.html}
\end{frame}

\begin{frame}{Set Based DBIx::Class}
\begin{itemize}
\item ORM
\begin{itemize}
\item Objects
\item Abstracts SQL
\item ...
\end{itemize}
\item ResultSet
\begin{itemize}
\item Chaining
\item Relationship Traversal
\item Correlated Subqueries
\item ...
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Using ResultSet}
\begin{itemize}
\item Simple SQL query
\item Turn into DBIx::Class search
\item Use ResultSet features
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Simple SQL query}
List of talks on last day of Perl Dancer Conference:
\begin{lstlisting}
SELECT talks_id, author_id, conferences_id, duration,
title, tags, abstract, url, comments, accepted, confirmed, 
lightning, scheduled, start_time, room, survey_id 
FROM talks 
WHERE accepted is TRUE 
AND conferences_id = 1 
AND room != '' 
AND start_time >= '2015-10-22 00:00:00'
AND start_time <= '2015-10-23 00:00:00'
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Simple SQL query}
With DBIx::Class:
\begin{lstlisting}
my $talks = $schema->resultset('Talk')->search(
    {
        -bool          => 'accepted',
        conferences_id => 1,
        room           => { '!=' => '' },
        start_time     => {
            '>=' => '2015-10-22 00:00:00'
            '<=' => '2015-10-23 00:00:00'
            },
    },
);
\end{lstlisting}
\end{frame}

\subsection{Truth of ResultSet}
\note{
  If you hear the term ResultSet, you probably thing
  we are talking about a number of results aka
  table rows.
}

\begin{frame}{Truth of ResultSet}
\begin{figure}[!ht]
\centering
\includegraphics[width=0.5\linewidth]{img/pdc_users.jpg}
\end{figure}
\end{frame}

% https://pixabay.com/en/wrong-way-sign-road-caution-167535/

\begin{frame}{Truth of ResultSet}
\begin{figure}[!ht]
\centering
\includegraphics[width=1\linewidth]{img/wrong-way.jpg}
\end{figure}
\end{frame}

\begin{frame}[fragile]{Truth of ResultSet}
% \centering
\sout{ResultSet}

\begin{lstlisting}
isa(Query Plan);
\end{lstlisting}

\end{frame}

\begin{frame}[fragile]{Truth of ResultSet}

This doesn't execute SQL:

\begin{lstlisting}
my $talks = $schema->resultset('Talk')->search(...);
\end{lstlisting}

This does:

\begin{lstlisting}
my $first_talk = $schema->resultset('Talk')
                 ->search(...)->first;
\end{lstlisting}

\end{frame}

\section{Composability}

Composability means that you don't need to construct the
complete at once, but compose it together, e.g with
chaining.

The underlying mechanism is that \verb|->search| on a
ResultSet actually doesn't search.

\subsection{Tickets}

\begin{frame}{Tickets}
\begin{figure}[!ht]
\centering
\includegraphics[width=0.8\linewidth]{img/cinema-ticket.png}
\end{figure}
\end{frame}

\begin{frame}{Tickets}
\begin{figure}[!ht]
\centering
\includegraphics[width=0.8\linewidth]{img/ticket-view.png}
\end{figure}
\end{frame}

\begin{frame}[fragile]{Tickets with inventory}
\begin{itemize}
\item Conference
\item Products (tickets)
\item Conference Tickets
\item Inventory
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Tickets with inventory}
\begin{lstlisting}

SELECT ticket.sku, ticket.name, 
  ticket.short_description, ticket.description, 
  ticket.price, inventory.sku, inventory.quantity 
  FROM conference_tickets me 
  JOIN products ticket 
    ON ticket.sku = me.sku 
  LEFT JOIN inventories inventory 
    ON inventory.sku = ticket.sku 
WHERE me.conferences_id = '2' AND ticket.active = '1'

\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Tickets}

\begin{lstlisting}
  $tickets = $schema->resultset( 'Conference' )
     ->find( {name => 'Perl Dancer Conference 2016'}, )
     ->tickets
     ->active
     ->prefetch('inventory');
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Tickets - Relationship Traversal}
\begin{lstlisting}
package PerlDance::Schema::Result::Conference;

...

has_many
  conference_tickets => 'PerlDance::Schema::Result::ConferenceTicket',
  "conferences_id";

many_to_many tickets => "conference_tickets", "ticket";

\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Tickets - Predefined Search}
\begin{lstlisting}

package Interchange6::Schema::ResultSet::Product;

...

sub active {
    return $_[0]->search({ $_[0]->me('active') => 1 });
}

\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Tickets - Helpers}

DBIx::Class::Helper::ResultSet::Shortcut

\begin{lstlisting}
$tickets_rs->search( undef, { prefetch => 'inventory' } );

$tickets_rs->prefetch('inventory');
\end{lstlisting}
\end{frame}

\subsection{Talks with number of attendees}

\begin{frame}{Talks with number of attendees}
\begin{figure}[!ht]
\centering
\includegraphics[width=0.8\linewidth]{img/schedule2015.png}
\end{figure}
\end{frame}

\begin{frame}[fragile]{The naive way}
\begin{lstlisting}
my @data = map +{
   %{ $_->as_hash },
   attendee_count => $_->attendee_talks->count,
}, $talks_rs->all
\end{lstlisting}

Problem: one extra query per talk

\end{frame}

\begin{frame}[fragile]{Correlated Subqueries}
\begin{lstlisting}
package PerlDance::Schema::ResultSet::Talk;

...

sub with_attendee_count {
  my $self = shift;

  $self->search(
    undef,
      {
        '+columns' => {
           attendee_count =>
             $self->correlate('attendee_talks')
               ->count_rs
               ->as_query
        }
      }
  );
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Correlated Subqueries}
\begin{lstlisting}
( 
  SELECT COUNT( * ) 
  FROM "attendee_talks" "attendee_talks_alias" 
  WHERE "attendee_talks_alias"."talks_id" = "me"."talks_id"
), 
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Correlated Subqueries}
\begin{lstlisting}
my $talks = rset('Talk')->search(
  {
    accepted       => 1,
    conferences_id => setting('conferences_id'),
    room           => { '!=' => '' },
    start_time     => {
      '!=' => undef,
      '>=' => $schema->format_datetime($dt_date),
      '<=' =>
         $schema->format_datetime( 
           $dt_date->clone->add( days => 1 ) )
    },
  },
  {
    order_by => 'start_time',
    prefetch => 'author',
  }
)->with_attendee_count;
\end{lstlisting}
\end{frame}

\begin{frame}{Talks with number of attendees}
\begin{figure}[!ht]
\centering
\includegraphics[width=0.8\linewidth]{img/schedule2015.png}
\end{figure}
\end{frame}

\begin{frame}[fragile]{Correlated Subqueries}
\begin{lstlisting}
sub with_attendee_status {
  my ( $self, $users_id ) = @_;

  $self->search(
    undef,
    {
      '+columns' => {
        attendee_status => 
          $self->correlate('attendee_talks')->search(
          {
            users_id => $users_id
          }
        )->count_rs->as_query
      }
    }
  );
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Correlated Subqueries}
\begin{lstlisting}
$talks = $talks->with_attendee_status( $user->id );
\end{lstlisting}

\begin{lstlisting}
( 
    SELECT COUNT( * ) 
      FROM "attendee_talks" "attendee_talks_alias" 
    WHERE "attendee_talks_alias"."talks_id" = "me"."talks_id" AND "users_id" = '4'
), 
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Correlated Subqueries}
\begin{lstlisting}
      
$talks = $talks->with_attendee_status( $user->id );

\end{lstlisting}
\end{frame}

\section{Other Nice Stuff}

\begin{frame}{Other Nice Stuff}
\begin{itemize}
\note{Sugar for DBIx::Class}
\item Subclassing Schema
\item Helpers
\item Deployment Handler
\end{itemize}
\end{frame}

\subsection{Subclassing Schemas}

\begin{frame}[fragile]{Use cases for subclassing}
\begin{itemize}
\item Generic schema e.g. \verb|Interchange6::Schema|
\item Applications with similar databases
\end{itemize}
\end{frame}

\begin{frame}{Subclassing}
\begin{itemize}
\item Add new tables
\item Add new columns to existing tables
\item Add new relations
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Subclass Example}
\begin{lstlisting}
package PerlDance::Schema;
our $VERSION = 16;

use Interchange6::Schema::Result::User;
package Interchange6::Schema::Result::User;

__PACKAGE__->add_columns(
    bio => { data_type => "varchar", size => 2048, 
             default_value => '' },
    media_id =>
      { data_type => "integer", is_nullable => 1 },
    pause_id => { data_type => "varchar", size => 128, 
        default_value => '' },
    t_shirt_size => { data_type => "varchar", size => 8, 
      is_nullable => 1 },
);
\end{lstlisting}
\end{frame}

Inherit from \verb|Interchange6::Schema| and set result namespace to 
\verb|Interchange6::Schema::Result| plus \verb|PerlDance::Schema::Result|.

\begin{frame}[fragile]{Subclass Example}
\begin{lstlisting}
package PerlDance::Schema;

use base 'Interchange6::Schema';

Interchange6::Schema->load_namespaces(
    default_resultset_class => 'ResultSet',
    result_namespace        =>
        [ 'Result', '+PerlDance::Schema::Result' ],
    resultset_namespace     =>
        [ 'ResultSet', '+PerlDance::Schema::ResultSet' ],
);
\end{lstlisting}
\end{frame}



\section{DBIx::Class Helpers}

\begin{frame}{DBIx::Class Helpers}
Simplify the common case stuff for DBIx::Class.
\end{frame}

\begin{frame}{DBIx::Class Helpers}
\begin{figure}[!ht]
\centering
\includegraphics[width=0.4\linewidth]{img/frew.png}
\caption{Arthur Axel "fREW" Schmidt}
\end{figure}
\end{frame}

% list of helpers we show

\begin{frame}{DBIx::Class Helpers}
\begin{itemize}
\item Helper::Schema::QuoteNames
\item Helper::ResultSet::Me
\item Helper::Row::OnColumnChange
\item Helper::Schema::DateTime
\end{itemize}
\end{frame}

\subsection{Helper::QuoteNames}

\begin{frame}[fragile]{Helper::QuoteNames}
\begin{itemize}
\item Escaping reserved words
\item Differ between engines and version
\item e.g. MySQL
\begin{itemize}
\item \verb|select user from userdb| => crash
\item \verb|select `user` from `userdb`| => works
\end{itemize}
\item \verb|quote_names| in connection info
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Helper::QuoteNames}
\begin{lstlisting}

package Interchange6::Schema;

use base 'DBIx::Class::Schema';

__PACKAGE__->load_components( 
    'Helper::Schema::QuoteNames' 
);

...

\end{lstlisting}
\end{frame}

\subsection{Helper::ResultSet::Me}

Predefined queries present a problem: what is the table alias I need to use?
We can do:

\begin{frame}[fragile]{Helper::Resultset::Me}
\begin{lstlisting}
sub in_germany {
    my $self = shift;
    my $current_source_alias =
        $self->current_source_alias;
    return $self->search(
        { "$current_source_alias.country_iso_code"
          => 'DE' }
    );
}
\end{lstlisting}
\end{frame}

but using this helper makes things much simpler:

\begin{frame}[fragile]{Helper::Resultset::Me}
\begin{lstlisting}
sub in_germany {
    my $self = shift;


    return $self->search(
        { $self->me('country_iso_code') => 'DE' }
    );

}
\end{lstlisting}
\end{frame}

\subsection{HashRefInflator}

Using the HashRefInflator makes sense when you need to quickly retrieve
data from a massive resultset or you need a list of hash references anyway,
e.g. for input to a template in a web application.

\begin{frame}[fragile]{HashRefInflator}
\begin{lstlisting}
my $rs = $schema->resultset('Country')->search({}, {
   result_class
     => 'DBIx::Class::ResultClass::HashRefInflator',
 });
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{HashRefInflator with HRI helper}
\begin{lstlisting}
my $rs = $schema->resultset('Country')->search({})->hri;

# since 'search' here is redundant we can just use:
my $rs = $schema->resultset('Country')->hri;
\end{lstlisting}
\end{frame}

\section{Conclusion}

\begin{frame}{Conclusion}
\begin{itemize}
\item Starting with DBIx::Class
\item Resources
\item Slides
\item Questions
\end{itemize}
\end{frame}

\subsection{Starting with DBIx::Class}

You can use \verb|dbicdump| to create a ``boilerplate'' schema from the
existing database.

\begin{frame}[fragile]{dbicdump}
\begin{lstlisting}
dbicdump -o dump_directory=/home/dance/TravelDance/lib 
         TravelDance::Schema 
         dbi:Pg:dbname=perldance
\end{lstlisting}
\end{frame}

\subsection{Resources}
\begin{frame}[fragile]{Resources}
\begin{itemize}
\item Extensive Documentation
\begin{itemize}
\item \verb|DBIx::Class::Manual::*|
\item \verb|DBIx::Class::Manual::ResultClass|
\item \verb|DBIx::Class::ResultSet|
\item \verb|DBIx::Class::Relationship::*|
\end{itemize}
\item \href{http://www.perladvent.org/2012/2012-12-21.html}
{Perl Advent Calendar 2012: Set-based DBIx::Class}
by fRew
\end{itemize}
\end{frame}

\subsection{Slides}

\begin{frame}{Slides}
Slides:
\url{http://www.linuxia.de/talks/amsx2015/dbic-pr-en-beamer.pdf}
\end{frame}

\subsection{Finish}

\begin{frame}{Questions}
\centering
Questions ?
\end{frame}

\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
